//-*- compile-command: "cd .. && make -k && cd -" -*-

/**

   Usage: ./mcdm [-in parameterfile] [lots of options]

   Call it with --help to get a list of options.

   When called without arguments, it will generate a template parameter file called
   "template.txt" using the default parameter values.

   When called with the --in argument, it will use values from the parameter file.

**/

#include "stdbool.h"
#include "math.h"
#include "stdlib.h"
#include "stdio.h"
#include "unistd.h"
#include "assert.h"
#include "float.h"
#include "signal.h"
#include "stdarg.h"
#ifdef HAVE_MPI
#include "mpi.h"
#endif
#include "gsl/gsl_rng.h"
#include "gsl/gsl_randist.h"
#include "gsl/gsl_interp.h"
#include "gsl/gsl_sort.h"

#include "../utils/par.h"
#include "../utils/utils.h"
#include "../utils/v.h"

#define sqr(x) ((x)*(x))

#define AU 1.5e13
#define MSUN 2e33
#define MJUP 1.989e30
#define MEARTH 5.9e27
#define MUNIT MSUN // Mass unit (g)
#define MSTAR (MSUN/(MUNIT))
#define G 6.67e-8
#define TUNIT (sqrt(AU*AU*AU/(G*MUNIT))) // Time unit (s)
#define YEAR (TUNIT/3.14e7) 
#define RHOUNIT (MUNIT/(AU*AU*AU)) // Density unit (g/cm^3)
#define SIGMAUNIT (MUNIT/(AU*AU)) // Surface density unit (g/cm^2)
#define VUNIT (AU/TUNIT) // Speed unit (cm/s)
#define RUNIT AU // Length unit (cm)
#define ENERGYUNIT (MUNIT*(RUNIT*RUNIT)/(TUNIT*TUNIT)) // Energy unit (erg)
#define TEMPUNIT (150.) // Temperature unit (K)
#define FORCEUNIT (MUNIT*(RUNIT)/(TUNIT*TUNIT))

#define STOP_ZERO_RATE -1

#define VER "1.0"
#define BANNER "MCDiskMass " VER " - Stefano Meschiari - 2014\n"

#define DIAGS(label, value) do { if (fid_diags == NULL) break; fprintf(fid_diags, sformat, label); fprintf(fid_diags, eformat, (double) value); fprintf(fid_diags, "\n"); fflush(fid_diags); } while(0)

#ifndef NDEBUG
#define unused __attribute((unused))
#else
#define unused REMOVE_THIS_VARIABLE
#endif


double output(const double time, const double dt);

// START_PARAMETERS
// PARAMETERS BELOW ARE READ FROM THE INPUT FILE (i.e. whatever is passed via -in), OR THE COMMAND LINE (in the form --name value)
//  
// Density (constant), g/cm^3 [1.5]
double rho;
// Maximum number of MC bodies [1000]
long N;
// Minimum size of bodies, cm [1e-4]
double R_min;
// Maximum size of bodies, cm [1000e5]
double R_max;
// Size of the annulus, AU [0.1]
double da;
// Radius of the annulus, AU [10]
double a;
// Gas surface density at 1 AU, g/cm^2 [1700]
double Sigma_0;
// Surface density index, Sigma ~ Sigma_0 R^-Sigma_p [1.5]
double Sigma_p;
// Gas-to-dust ratio [100]
double gas_to_dust_ratio;
// Ice line enhancement past a_ice, AU [4]
double a_ice;
// Ice line enhancement factor for solids [4.2]
double f_ice;
// Fixed scale height h/R of planetesimal disk; calculated if negative [-1]
double h;
// Scale height H/R of gas disk [0.04]
double H;
// Turbulent alpha [1e-4]
double alpha;
// Initial distribution of bodies, dN/dR ~ R^-pg [3.5]
double pg;
// Fill up the initial distribution up to this size, cm [100]
double R_fill;
// Maximum size of bodies that behave like dust, cm [1]
double R_dust;
// Minimum size of bodies that form planetesimals, cm [10]
double R_source_min;
// Maximum size of bodies that form planetesimals, cm [100]
double R_source_max;
// Maximum size of bouncing bodies, -1 for bouncing self-consistently calculated from collision speeds, cm [-1]
double R_bounce;
// Planetesimal formation efficiency, epsilon [1e-4]
double eps_pl;
// Min. size of planetesimals generated by the source bin, cm [1e5]
double R_planetesimal;
// Max. size of planetesimals generated by the source bin, cm [50e5]
double R_planetesimal_2;
// Strength of planetesimals, 1 for strong, 0 for weak [1]
long strength;
// Distribution of small fragments from collision, dN/dR ~ R^-pf (dN/dM ~ M^-(pf+2)/3) [1.93]
double pf;
// Planetesimal size distribution when created, dN/dR ~ R^-pp [1]
double pp;
// Type of velocity distribution, 0 for constant collision speed, -1 for turbulent only, 1 for turbulent + drift [-1]
long vd;
// ***********
// Parameters for freezing/melting physics: all are taken from
// Wettlaufer (2010) or engineeringtoolbox.com
// ***********
// Freezing/melting physics: 0 if off, 1 if on [0]
long freezing;
// Young's modulus of water, dynes/cm^2 [5.3e10]
double young_m;
// Fraction of energy lost to melting or surface damage in each collision [0.2]
double f_damage;
// Equilibrium pressure Pm for ice particles at the pre-collision freezing temperature, dyne/cm^2 [1.15e10]
double P_premelt;
// Pre-collision temperature of ice, K WARNING: must match P_premelt. See Fig. 1 of Wettlaufer (2010) [100.] 
double unused T_ice;
// Melting temperature of solid ice, K [273.]
double T_melt;
// Density of cold pre-melt liquid, g/cm^3 [1.0]
double rho_premelt;
// Latent heat of fusion or amorphization, erg/g for water [3.34e9]
double q_fusion;
// Thermal conductivity of solid, erg/(s cm K) for ice [3.5e5]
double k_therm;
// Sound speed in solid, cm/s for ice [3.0e5]
double c_solid;
// Grouping collisions (1=on, 0=off) [1]
long group_collisions;
// Mass precision for collision grouping [1e-4]
double dM_prec;
// Automatic accretion threshold; if the mass ratio M_small/M_large is less than this, accretion [1e-8]
double M_threshold;
// Typical encounter speed, only used if vd = 0, cm/s [5e2]
double dv_fixed;
// Output file interval, years [1e3]
double dt_out;
// Output interval of rates, don't output if negative, years (note: each file is large) [-1]
double dt_rates;
// Total simulation time, years [1e6]
double t_max;
// Add seeds at/after this time (if negative, no seeds are added), years [-1]
double t_seeds;
// Size of seeds, cm [1]
double R_seeds;
// Output bin number [1e3]
double N_bin;
// Minimum N_{phys} per particle; if any smaller than this, the program will terminate [1e3]
double N_phys_limit;
// Debug level, 0 = silent, 3 = at every dt [0]
long debug_level;
// Seed of random number generator [1234]
long seed;
// Tag [0]
long tag;
// Output directory [.]
string out;
// Format [%17]
string format;
// Dry run? If 1, only generate outcome matrix [0]
long dry_run;
// Resume from the specified time [-1]
double resume_time;
// END_PARAMETERS

// Global variables

// The MC particles
double* M;
double* R;
// Total mass in solids
double M_tot;
// Angular speed at a
double Omega;
// Sigma solids
double Sigma;
// Sigma gas
double Sigma_g;
// Gas density
double rho_g;
// Gas sound speed
double c_g;
// Turbulent Reynolds number, Re = (alpha c_g H a)/nu;
double Re_t = 1e13;
// Eddy velocity, v_e = alpha^0.5 c
double v_e;
// Mass in dust
double M_dust;
// Mass in particles
double M_mc;
// Timescale for planetesimal formation
double tau;
// Gas pressure
double P_gas;
// Gas temperature
double T_gas;

// Rng
gsl_rng* rng;
// Time
double time = 0.;
double t_out = 0.;
// Rates matrix
double** rates_ik;
double** events_normal_ik;
double** dv_ik;
// Rates vector
double* rates;
double pl_creation_rate;
double* cum_rates;
int* interacting;
// Index vector [used in many different places to store indices]
int* indices;
// Average dt -- used to track simulation bottlenecks
double dt_average = 0;
double dt_average_N = 0;
// Format for floats and strings
string eformat;
string sformat;
// Process identifier
int rank;
int world_size;

// Handle for diagnostics file
static FILE* fid_info = NULL;
static FILE* fid_out = NULL;
static FILE* fid_diags = NULL;
static FILE* fid_summ = NULL;

// When the mass ratio is very unequal, one should assume perfect accretion (otherwise mass accretion is lost in
// floating point round-off)
#define FRAG_LIKELY_ACCRETING_HIGH_MASS_RATIO 1
#define FRAG_PRINT_DEBUG_INFO 2
#define FRAG_BOUNCING_ALWAYS 4

#define VD_FIXED 0
#define VD_TURBULENCE_ONLY -1
#define VD_FULL 1

// Calculates the largest fragment from the collision of m1 and m2
// at the speed dv. flag prints out some diagnostics if true.
double mfrag(double m1, double m2, double rho_pl, double dv, int strength, int* flag) {

  if (MIN(m1, m2)/MAX(m1, m2) < M_threshold) {
    *flag = FRAG_LIKELY_ACCRETING_HIGH_MASS_RATIO;
    return m1+m2;
  }

	dv *= VUNIT;
	m1 *= MUNIT;
	m2 *= MUNIT;
	rho_pl *= RHOUNIT;
	double alpha, Phi, qs, qg, eta;
	eta = -1.5;
		
	if (strength == 0) {
		alpha = 0.4;
		Phi = 7;
		qs = 500;
		qg = 1e-4;
	} else {
		alpha = 0.5;
		Phi = 8;
		qs = 7e-4;
		qg = 1e-4;
	}
	
	double mu = m1*m2/(m1+m2);
	double s = cbrt(m1/(4./3.*M_PI*rho_pl)+m2/(4./3.*M_PI*rho_pl));

	double Q = 0.5 * mu * dv * dv / (m1+m2);
	double Q_star = qs*pow(s, 9.*alpha/(3-2.*Phi)) * pow(dv, 2.-3.*alpha) + 
		qg * pow(s, 3.*alpha) * pow(dv, 2.-3*alpha);

	double m_lr;

	if (Q/Q_star > 1.8) {
		// supercatastrophic
		m_lr = 0.1/pow(1.8, eta) * pow(Q/Q_star, eta) * (m1+m2);
	} else {
		m_lr = (1.-0.5*Q/Q_star)*(m1+m2);
		
		if (*flag & FRAG_PRINT_DEBUG_INFO) {
			printf("%e\n", rho_pl);
			printf("%e %e\n", cbrt(m1/(4./3.*M_PI*rho_pl)), cbrt(m2/(4./3.*M_PI*rho_pl)));
			printf("%e %e %e\n", Q, Q_star, Q/Q_star);
			printf("%e\n", s);
			printf("%e %e\n", qg, qs);
			
		}
	};

  *flag = 0;
	return m_lr/MUNIT;
};

// Stopping time of a particle of given mass (m) and radius (r)
double stopping_time(const double m, const double r) {
  return 3./4. * m / (4.*c_g*rho_g * M_PI * r * r);
}


typedef enum {
  STICKING = 0,       // Hit and stick
  BOUNCING = 1,       // Bouncing
  TRANSFER = 2,       // Mass transfer 
  FRAGMENTING = 3,    // Fragmentation; M_f (mass of largest fragment) is returned
  MERGING_VESC = 4,   // dv < v_esc
  FREEZING = 5        // Hit, melt and freeze
} outcome_t;


bool freeze(const double M_i, const double M_k,
            const double R_i, const double R_k,
            const double dv, double* tau_freeze, double* tau_contact, double* E_binding, double* E_collision) {
    
    // Reduced mass and radius of collision pair
    double m_reduced = (M_i*M_k / (M_i + M_k));
    double r_reduced = (R_i*R_k / (R_i + R_k));

    // Collision energy
    double c_energy = 0.5 * m_reduced * pow(dv,2.);
    
    // Contact time of collision pair
    double tau_c = 2.87 * pow(pow(m_reduced,2.) /
                                    (r_reduced * dv * pow(young_m,2.) * pow(f_damage,5.)), 0.2);
    
    // Contact radius in collison
    double r_contact = pow(15. * m_reduced * pow(r_reduced,2.)
                           * pow(dv,2.) / (16. * young_m), 0.2);
    
    // Assume, for now, that ice temperature = gas temperature
    double T_ice = T_gas;

    // Delta T between melt layer and solid ice
    double deltaT = T_melt - T_ice;

    
    // Collision pressure at interface
    double unused P_coll = 3./(2.*M_PI) * pow((4./3.),0.8) *
      pow(5.*m_reduced*pow(dv,2.)*pow(young_m,4.) / (4.*pow(r_reduced,3.)), 1./5.);
    
    // Thickness d of melt layer
    double dthick = f_damage*c_energy /
      (M_PI*pow(r_contact,2.) * (rho_premelt * (q_fusion/T_melt) *
      deltaT + ((rho_premelt-rho)/rho) * (P_premelt - f_damage*P_coll)));
    
    
    // Find smaller particle
    double rsmall;
    if (R_i < R_k) {
      rsmall = R_i;
    } else {
      rsmall = R_k;
    };
    
    // Freezing time
    double tau_f = rho * q_fusion * rsmall * dthick / (12. * k_therm * deltaT);

    *tau_freeze = tau_f;
    *tau_contact = tau_c;

    double mu_ice = 18.;
    double m_H = 1.6e-24/MUNIT;
    double U_binding = 4.8e-13 / ENERGYUNIT;

    
    double E_b = M_PI*pow2(r_contact) * dthick * rho / (mu_ice * m_H) * U_binding;
    double E_c = (1.-f_damage) * 0.5 * m_reduced * dv * dv;

    *E_binding = E_b;
    *E_collision = E_c;
    
    // Find out if collision results in fusion
    return (tau_f < tau_c);// && E_b > E_c);        
}

// Returns the "outcome" of the collision, one of the enums in outcome_t.
// Formulas are from Windmark '12.

outcome_t outcome(const double M_i, const double M_k,
                  const double R_i, const double R_k,
                  const double dv,
                  double* M_t_new, double* M_p_new, int* flag) {
  const double M_s = 3e-12/MUNIT;
  const double M_b = 3e-3/MUNIT;
  *flag = 0;
  
  double M_t, M_p, R_t, R_p;
  
  if (M_i < M_k) {
    M_p = M_i; R_p = R_i;
    M_t = M_k; R_t = R_k;
  } else {
    M_p = M_k; R_p = R_k;
    M_t = M_i; R_t = R_i;
  }
  
  double v_stick = pow(M_p/M_s, -5./18.)/VUNIT;
  double v_bounce = pow(M_p/M_b, -5./18.)/VUNIT;
  double v_esc = sqrt(2.*(M_i+M_k)/(R_i+R_k));

  double dummy;
  
  if (freezing && freeze(M_i, M_k, R_i, R_k, dv, &dummy, &dummy, &dummy, &dummy)) {
    *M_t_new = M_t+M_p;
    *M_p_new = 0.;
    return FREEZING;
  }
  
  if (dv < v_stick) {
    if (M_p/M_t < M_threshold)
      *flag = FRAG_LIKELY_ACCRETING_HIGH_MASS_RATIO;
    *M_t_new = M_t + M_p;
    *M_p_new = 0.;
    return STICKING; // Low velocity, hit and stick
  } else if (dv < v_esc) {
    if (M_p/M_t < M_threshold)
      *flag = FRAG_LIKELY_ACCRETING_HIGH_MASS_RATIO;
    *M_t_new = M_t + M_p;
    *M_p_new = 0.;
    return MERGING_VESC; // Low velocity compared to escape velocity; hit and merge
  } else if (dv < v_bounce) {
    const double k_1 = 0.4;
    const double k_2 = log10(M_p/M_s)/log10(M_b/M_s);
    double p_c = 1 - k_1 * log10(dv * VUNIT) - k_2;
    
    if (gsl_rng_uniform(rng) < p_c) {
      if (M_p/M_t < M_threshold)
        *flag = FRAG_LIKELY_ACCRETING_HIGH_MASS_RATIO;
      *M_t_new = M_t + M_p;
      *M_p_new = 0.;
      return STICKING; // Low velocity, hit and stick
    } else {
      *M_t_new = M_t;
      *M_p_new = M_p;
      return BOUNCING;
    }
  } else {
    // Windmark'12, Eqns. (5)-(12), pg. 7
    const double alpha = -0.068;
    const unused double beta = -0.43;
    const double C = 3.27;
    const double gamma = 0.16;
    const double m_1 = 3.67e7;
    
    double v_1p = pow(M_p*MUNIT/m_1, -gamma)/VUNIT;

    if (dv < v_1p) {
      *M_t_new = M_t;
      *M_p_new = M_p;
      *flag = FRAG_BOUNCING_ALWAYS;
      return BOUNCING; // Low velocity compared to fragmentation threshold; bounce
    }
    double unused v_p = dv/(1.+M_p/M_t);
    double unused v_t = dv/(1.+M_t/M_p);
    double unused mu_p = C*pow(M_p*MUNIT, alpha) * pow(v_p * VUNIT, beta);
    double unused mu_t = C*pow(M_t*MUNIT, alpha) * pow(v_t * VUNIT, beta);

    // Windmark'12, Eqns. (14)-(20)
    const double v_1beitz = 13;
    double eps_ac = -6.8e-3 + 2.8e-4 * v_1beitz/(v_1p*VUNIT) * dv*VUNIT;
    eps_ac = MIN(eps_ac, 0.5);

    const double a = 9.3e-6;
    const double b = -0.4;
    const double k = 0.15;
    const double m_0 = 3.5e-12;

    double m_er = (a * pow(M_p*MUNIT/m_0, k) * dv * VUNIT + b) * M_p;
    double m_mt = eps_ac * M_p;

    if (mu_p < 1 && mu_t > 1) {
      *M_p_new = (1.-eps_ac)*mu_p*M_p;
      *M_t_new = M_t + m_mt - m_er;

      return TRANSFER;
    } else {
      *M_p_new = mu_p * M_p;
      *M_t_new = mu_t * M_t;

      return FRAGMENTING;
    }
  }
};

// Eqn. 51 of Birnstiel+ 2010
double disk_height(const double M_i, const double R_i) {
  if (h < 0) {
    double St_i = stopping_time(M_i, R_i) * Omega;
    return H * MIN(1., sqrt(alpha / ((MIN(St_i, 0.5) * (1+St_i*St_i)))));
  } else
    return h;
}

// Calculates the turbulent collision speed (from turbulent drag only.)
double turbulent_coll_speed(const double M_i, const double M_k,
                            const double R_i, const double R_k) {
  // Stopping times of particles i and k
  double ts_i = stopping_time(M_i, R_i);
  double ts_k = stopping_time(M_k, R_k);
  double ts_m = MIN(ts_i, ts_k);
  double ts_M = MAX(ts_i, ts_k);
  
  // Eddy speeds
  double td = 1./Omega;
  double tnu = td / sqrt(Re_t);
  double dv;
  
  if (ts_M < tnu) {
    dv = sqrt(sqr(ts_i-ts_k)/(td * (ts_i + ts_k))) * v_e;
  } else if (ts_m < td && ts_M > td) {
    dv = v_e;
  } else if (ts_M > td) {
    dv = sqrt(td/(td+ts_i) + td/(td+ts_k)) * v_e;
  } else {
    dv = 3./(ts_i+ts_k) * sqrt(pow3(ts_M)/td) * v_e;
  };
  
  return dv;
}

void save_velocity_outcome() {
  string fn;
  sprintf(fn, "%s/outcomes.txt", out);
  FILE* fid = fopen(fn, "w");
  int bins = 200;

  double* rr = logspace(bins, log10(1e-4/RUNIT), log10(1e7/RUNIT));
  fprintf(fid, "# R_1 R_2 dv outcome[0=stick, 1=bounce, 2=erosion+transfer, 3=fragm, 4=grav.merge, 5=freezing] mass_new/mass_old\n");
  for (int i = 0; i < bins; i++)
    for (int k = 0; k < bins; k++) {
      double M_i = pow3(rr[i]) * 4./3. * M_PI * rho;
      double M_k = pow3(rr[k]) * 4./3. * M_PI * rho;
      double dv = turbulent_coll_speed(M_i, M_k, rr[i], rr[k]);
      if (vd == VD_FIXED)
        dv = dv_fixed;
      
      double v_esc = sqrt(2.*(M_i+M_k)/(rr[i]+rr[k]));
        
      double M_t_new, M_p_new;
      int flag;
      outcome_t o = outcome(M_i, M_k, rr[i], rr[k], dv, &M_t_new, &M_p_new, &flag);

      fprintf(fid, "%e %e %e %d %e %e %e\n", rr[i]*RUNIT, rr[k]*RUNIT,
              dv*VUNIT, o, M_t_new/MAX(M_i, M_k)-1, v_esc*VUNIT, M_t_new);      
    }
  
  fclose(fid);
}


double power_law_distribution(double x, void* alpha) {
  return pow(x, -*((double*)alpha));
};

// Returns a random planetesimal mass, distributed according to
// dN/dR ~ R^{-pp}
void get_planetesimal(double* M_pl, double* R_pl) {
  static int pidx = 0;
  static const int PNUM = 50000;
  static double* pmasses = NULL;
  
  if (pmasses == NULL || pidx == PNUM) {
    if (pmasses == NULL)
      pmasses = zeros(PNUM);
    
    INFO("Generating next batch of planetesimal sizes...\n");
    
    sample(power_law_distribution, &pp, rng, R_planetesimal,
           R_planetesimal_2, PNUM, pmasses);
    
    for (int i = 0; i < PNUM; i++)
      pmasses[i] = 4./3.*M_PI*rho*pow3(pmasses[i]);
    
    pidx = 0;
  }
  *M_pl = pmasses[pidx++];
  *R_pl = pow(*M_pl/(4./3.*M_PI*rho), 1./3.);
};

// Counts the number of objects between R_1 and R_2.
// Remember: each body represents N_i = M_{mc}/N M[i], for a total
// mass M_i = M_{mc}/N. Therefore, the fraction of mass in a given
// radius interval (R_1, R_2) is
//
// f_12 = (\sum_{R_i > R_1 & R_i < R_2} M[i] M_mc/N M[i])/M_mc -> f_12 = 1/N \sum_i 1
//
// e.g. the fraction of particles with R_1 < R < R_2!
int count(const double R_1, const double R_2) {
  int count = 0;
  for (int i = 0; i < N; i++)
    if (R[i] > R_1 && R[i] < R_2)
      count++;
  return count;
}

int sample_cum(const double* cum_rates) {
  double v = (cum_rates[N-1])*gsl_rng_uniform(rng);
  if (v < cum_rates[0])
    return 0;
  else {
      int idx = gsl_interp_bsearch(cum_rates, v, 0, N-1)+1;
      assert(idx >= 0 && idx < N);
      return idx;
  }
}

// Calculate interaction rates. Interaction rates are given by
// r_i(k) = M_tot/(n m_k V) sigma_ik \delta v_ik. Normalize by mass,
// so that the matrix is symmetric to i and k (so the m_k term is added later),
// and the matrix can be stored as a lower triangular matrix.
void update_interaction_rates(int from, int to) {
  static bool _exit = false;
 
  
  for (int i = 0; i < N; i++)
    for (int k = 0; k < N; k++) 
      if ((i >= from && i <= to) || (k >= from && k <= to)) {
        
        if (R[i] <= R_bounce && R[k] <= R_bounce) {
          rates_ik[i][k] = 0.;
          events_normal_ik[i][k] = 1.;
        }
        else {
          double f = 1.;
          if (vd == VD_TURBULENCE_ONLY) {
            dv_ik[i][k] = turbulent_coll_speed(M[i], M[k], R[i], R[k]);
          }

          // Collision speed
          double dv = dv_ik[i][k];

          // Scale height of targets and projectiles
          double h_i = disk_height(M[i], R[i]);
          double h_k = disk_height(M[k], R[k]);

          // Number density of projectiles
          double Vol_k = M_PI * (pow2(a+da)-pow2(a)) * (h_k * a);
          double n_k = M_mc / (N * Vol_k * M[k]);

          // Correction for unequal scale heights
          double corr = MIN(h_i, h_k)/MAX(h_i, h_k);
          // Cross section
          double sigma_ik = M_PI * (pow2(R[i])+pow2(R[k]));

          
          // Rate 
          double r =  n_k * sigma_ik * dv * corr * interacting[i] * interacting[k];
          
          // Check if the mass after a collision changes significantly; if it
          // doesn't, use some tricks to increase timestep by "grouping" collisions.
          // Some rules for now:
          //
          // (1) The mass of the largest fragment must be larger than the mass of the
          // largest of the two bodies.
          //
          // (2) The mass NOT in the largest fragment must be very small; less than
          // some fraction of the original mass. This is essentially "straight" accretion.
          //
          // Special case: if frag_flag & FRAG_PRINT_DEBUG_INFO is true. This means that the
          // mass ratio is overwhelmingly large, and any accretion would be lost to floating
          // point rounding.
          int frag_flag = 0;
          double M_t_new;
          double M_p_new;
          
          outcome_t unused o = outcome(M[i], M[k], R[i], R[k], dv_ik[i][k],
                                       &M_t_new, &M_p_new, &frag_flag);

          if (o == BOUNCING && frag_flag == FRAG_BOUNCING_ALWAYS)
            r = 0;
          else if (group_collisions != 0 && M[i] > M[k]) {
            double M_frag = M_t_new;
            double dM = (M_frag - M[i]);


            /* TODO: Re-check that I'm doing the grouping of collisions correctly... */
            
            if ((frag_flag & FRAG_LIKELY_ACCRETING_HIGH_MASS_RATIO) || (fabs(dM) < dM_prec * M[i])) {
              
              if (frag_flag & FRAG_LIKELY_ACCRETING_HIGH_MASS_RATIO)
                f = dM_prec * MAX(M[i], M[k])/MIN(M[i], M[k]);
              else if (dM > 0.)
                f = dM_prec * M[i] / fabs(dM);
            }
            

            if (f < 1.)
              f = 1.;
          }

          rates_ik[i][k] = r/f;
          events_normal_ik[i][k] = f;
        }
      }
 
  double planetesimal_sources = 0;  
  for (int i = 0; i < N; i++)
    if (R[i] > R_source_min && R[i] < R_source_max) {
      planetesimal_sources ++;
    }

  
  double M_pl_sources = M_mc / N * planetesimal_sources;
  // dN/dt = M_sources/M_pl tau, is the rate of planetesimal production.
    
  pl_creation_rate = (M_pl_sources / tau)/(M_mc/N);

  if (_exit)
    exit(0);
};

// Get the index of a body in the "planetesimal source" range (R_source_min to R_source_max)
int get_random_planetesimal_source() {
  int l = 0;
  for (int i = 0; i < N; i++)
    if (R[i] >= R_source_min && R[i] <= R_source_max) {
      indices[l] = i;
      l++;
    }

  int idx = gsl_rng_uniform_int(rng, l);
  return indices[idx];
};


void pre_evolve_actions() {

  // After t_seeds, activate interaction of seeds with the rest of the bins
  if (t_seeds > 0 && interacting[0] == 0 && time > t_seeds) {
    zero(rates, N);

    for (int i = 0; i < N; i++) {
      for (int k = 0; k < N; k++) {
        rates[i] += rates_ik[i][k];
      }
    }

    int maxi, maxk;
    minmax_ik(rates_ik, N, N, &maxi, &maxk, true);
    
    interacting[0] = 1;
    update_interaction_rates(0, 0);
    
    INFO("%e %e %e %d %d %e %e\n", rates[0], maxv(rates, N), sum(rates, N), maxi, maxk, R[maxi]*RUNIT, R[maxk]*RUNIT);
    
    INFO("Seeds activated.\n");

    zero(rates, N);

    for (int i = 0; i < N; i++) {
      for (int k = 0; k < N; k++) {
        rates[i] += rates_ik[i][k];
      }
    }

    
    minmax_ik(rates_ik, N, N, &maxi, &maxk, true);

    INFO("%e %e %e %d %d %e %e\n", rates[0], maxv(rates, N), sum(rates, N), maxi, maxk, R[maxi]*RUNIT, R[maxk]*RUNIT);
  }

  // Only if debug_level is 2 or larger, check if there is a file called "print"; if so,
  // save the current state
  if (debug_level >= 2) {
    FILE* fid = fopen("print", "r");
    if (fid) {
      fclose(fid);
      output(time, 0);
    }
  }
}

double evolve() {
  double M_pl, R_pl;

  
  get_planetesimal(&M_pl, &R_pl);

  double rate_pl = pl_creation_rate;

  
  double rate = 0.;
  zero(rates, N);

  for (int i = 0; i < N; i++) {
    for (int k = 0; k < N; k++) {
      rates[i] += rates_ik[i][k];
      rate += rates_ik[i][k];
    }
  }
  
  // Check for number sanity
  assert(!isnan(rate) && !isinf(rate));
  assert(!isnan(rate_pl) && !isinf(rate_pl));
  assert(rate >= 0);
  assert(rate_pl >= 0);
  

  
  double rate_tot = rate + rate_pl;

  double r = gsl_rng_uniform(rng) * rate_tot;
  double dt = MIN(-1./rate_tot * log(gsl_rng_uniform(rng)), t_max-time);
  
  if (debug_level == 3) {
    INFO("t = %e [%e], dt = %e, rate = %e, rate_pl = %e, R_min = %e, R_max = %e\n", time, time*YEAR, dt, rate, rate_pl, minv(R, N)*AU, maxv(R, N)*AU);
  }
  
  if (time + dt > t_out + dt_out) {
    INFO("Grouping outputs between %e and %e...", time, time+dt);
    while (t_out < MIN(time+dt, t_max)) {
      t_out += dt_out;
      output(t_out, dt);
    }
    INFO("End grouping.\n");
  }

  dt_average += dt;
  dt_average_N += 1;
  
  if (r < VERY_SMALL_NUMBER)
    return dt;

  if (r < rate) {
    
    // Interaction between bodies; first find which will be the
    // i-labeled body
    
    cumsum(rates, cum_rates, N);
    int i = sample_cum(cum_rates);
    
    // Find the k-labeled body
    for (int k = 0; k < N; k++)
        rates[k] = rates_ik[i][k];
    
    cumsum(rates, cum_rates, N);
    int k = sample_cum(cum_rates);

    
    // Calculate the outcome. The largest particle is the "target" particle,
    // while the smallest particle is the "projectile".
    int frag_flag = 0;

    double M_t_new;
    double M_p_new;
    
    outcome_t unused o = outcome(M[i], M[k], R[i], R[k], dv_ik[i][k], &M_t_new, &M_p_new,
                          &frag_flag);    
    if (o != BOUNCING) {
      double M_old = M[i];
      double R_old = R[i];
      double M_new = M_t_new;
    
      double r = gsl_rng_uniform(rng);
    
      if (r < M_new/(M[i]+M[k])) {      
        double f = events_normal_ik[i][k];
      
        if (frag_flag & FRAG_LIKELY_ACCRETING_HIGH_MASS_RATIO) {
          M[i] = M[i] + f * M[k];
        } else {
          double M_ratio = M_new/M_old;
          M[i] = M[i] * pow(M_ratio, f);
        }
      
        double Rnew = pow(M[i]/(4./3. * M_PI * rho), 1./3.);

        if (MAX(R[i], R[k])*RUNIT > 1e6) {
          DEBUG_STOP("%e %e %e\n", R[i]*RUNIT, R[k]*RUNIT, Rnew*RUNIT);
        }
      
        R[i] = Rnew;
      
        update_interaction_rates(i, i);
      
      } else {
        double pf_m = 1./3. * (pf+2);
        double dM = (M[i]+M[k])-M_new;
        double M_min = 4./3.*M_PI*rho*pow3(R_dust);

        double* mass = log_sample(power_law_distribution, &pf_m, rng, M_min,
               dM, 1);

        
        double RR = pow(mass[0]/(4./3.*M_PI*rho), 1./3.);

        R[i] = RR;
        M[i] = mass[0];
        update_interaction_rates(i, i);
        free(mass);
      }

      // Check that numbers make sense
      if (isnan(M[i]) || isnan(R[i]) || isinf(M[i]) || isinf(R[i]))
        ERROR("Non-sensical result for particle %d [R = %e] after encounter w/ particle %d [R = %e]: %e\n",
              i, R_old, k, R[k], R[i]);
    }    
  } else {
    // Planetesimal creation
    int i unused = get_random_planetesimal_source();
    M[i] = M_pl;
    R[i] = R_pl;
    update_interaction_rates(i, i);
  }
  return dt;
};

double mass_frac_between(const double R_1, const double R_2) {
  return (1.-M_dust/M_tot) * count(R_1, R_2)/(double) N;
}



// Outputs a snapshot every dt_out. Snapshots are meant to be
// consumed by plots.r. Output is in binary format; the columns are
// saved in columns.txt.
//
// summary*.txt contains a "summary" of the fractional mass in each size bin.
// Columns are named with the upper range (e.g. M_SOURCE_MAX is the fractional
// mass in R_source_min < R <  R_source_max). Remember there are the following scales:
// R_dust, R_source_min, R_source_max, R_planetesimal, R_planetesimal_2
// (there is no max radius in these simulations!).
double output(const double time, const double dt) {
  const int min_size_log10 = -1;
  const int max_size_log10 = 7;

  
  static bool first_output = true;
  if (first_output) {
    string fn;
    if (rank == 0) {
      sprintf(fn, "%s/columns.txt", out);
      FILE* fid_out = fopen(fn, "w");
      if (!fid_out)
        ERROR("Could not save %s!\n", fn);
    
      string cf;

      for (int i = 0; i < N; i++) {
        sprintf(cf, "R%d", i+1);
        fprintf(fid_out, sformat, cf);
      }
      for (int i = 0; i < N; i++) {
        sprintf(cf, "M%d", i+1);
        fprintf(fid_out, sformat, cf);
      }      
      fprintf(fid_out, "\n");
      fclose(fid_out);
    };
    fprintf(fid_summ, sformat, "TIME");
    fprintf(fid_summ, sformat, "M_DUST");

    for (int i = min_size_log10; i <= max_size_log10; i++) {
      string colname;
      sprintf(colname, "M_%d", i);
      fprintf(fid_summ, sformat, colname);
    }    
    fprintf(fid_summ, sformat, "M_LARGER");
    fprintf(fid_summ, "\n");
    first_output = false;
  };

  fprintf(fid_summ, eformat, time*YEAR);
  fprintf(fid_summ, eformat, M_dust/M_tot);

  
  for (int i = min_size_log10; i <= max_size_log10; i++) {
    fprintf(fid_summ, eformat, mass_frac_between(pow(10., i)/RUNIT, pow(10., i+1)/RUNIT));
  }
  fprintf(fid_summ, eformat, mass_frac_between(pow(10., max_size_log10+1)/RUNIT, pow(10., 20)/RUNIT));
  fprintf(fid_summ, "\n");
  fwrite(R, sizeof(double), N, fid_out);
  fwrite(M, sizeof(double), N, fid_out);
  
  fflush(fid_out);
  fflush(fid_summ);

  INFO("\nyears = %e [dt = %e]\n[%.1e:%.1e] %.5e\t[%.1e:%.1e] %.1e\t[%.1e:%.1e] %.1e\t[%.1e:%.1e] %.1e [%.1e:inf] %.1e\n", time*YEAR, dt_average/dt_average_N*YEAR,
       RUNIT*R_dust, RUNIT*R_source_min, mass_frac_between(R_dust, R_source_min), RUNIT*R_source_min, RUNIT*R_source_max, mass_frac_between(R_source_min, R_source_max),
       RUNIT*R_source_max, RUNIT*R_planetesimal, mass_frac_between(R_source_max, R_planetesimal),
       RUNIT*R_planetesimal, RUNIT*R_planetesimal_2, mass_frac_between(R_planetesimal, R_planetesimal_2), RUNIT*R_planetesimal_2, mass_frac_between(R_planetesimal_2, 1e20));

  double min_N = M_mc / (N * maxv(M, N));
  if (min_N < N_phys_limit)
    ERROR("min_N < %e [M_max = %e, M_mc = %e, R_max = %e, M_mc = %e, R_min = %e]\n", min_N, maxv(M, N)*MUNIT, M_mc*MUNIT, maxv(R, N)*RUNIT, M_mc, minv(R, N) * RUNIT);
  
  INFO("min_N = %e, R_max = %e, R_min = %e\n", min_N, maxv(R, N) * RUNIT,  minv(R, N) * RUNIT);

  dt_average = dt_average_N = 0.;
  
  
  return 0;
};

void resume(const double resume_time) {
  INFO("Reading output files for rank %d...\n", rank);
  IF_MASTER_PROCESS {
    system("mkdir backup");
  }

  int unused n_columns = 2 * N; // radius and mass

  // Copy the "summary.%04d.txt" files
  string fn;
  sprintf(fn, "summary.%04d.txt", rank);

  string cmd;
  sprintf(cmd, "cp %s backup", fn);
  system(cmd);
  
  sprintf(fn, "backup/summary.%04d.txt", rank);
  
  FILE* fid = fopen(fn, "r");  
  if (!fid)
    ERROR("Could not open %s\n", fn);
  string str;
  int n = 0;
  int snap = 0;
  double deltat = 1e10;
  double actual_time = resume_time;
  
  while (fgets(str, sizeof(str)/sizeof(str[0]), fid) != NULL) {
    double t;
    sscanf(str, "%le", &t);
    if (fabs(t-resume_time) < deltat) {
      snap = n;
      deltat = fabs(t-resume_time);
      actual_time = t/YEAR;
    }
    n++;
  }
  
  

  rewind(fid);
  sprintf(fn, "summary.%04d.txt", rank);
  fid_summ = fopen(fn, "w");
  for (int i = 0; i < snap; i++) {
    fgets(str, sizeof(str)/sizeof(str[0]), fid);
    fprintf(fid_summ, "%s", str);
  }
  fclose(fid);

  
  sprintf(fn, "output.%04d.txt", rank);
  sprintf(cmd, "cp %s backup", fn);
  system(cmd);

  fid_out = fopen(fn, "w");
  
  sprintf(fn, "backup/output.%04d.txt", rank);
  
  fid = fopen(fn, "r");
  if (!fid)
    ERROR("Could not open %s\n", fn);

  for (int i = 0; i < snap; i++) {
    fread(R, sizeof(double), N, fid);
    fread(M, sizeof(double), N, fid);
    fwrite(R, sizeof(double), N, fid_out);
    fwrite(M, sizeof(double), N, fid_out);
  }
  fclose(fid);
  fclose(fid_out);

  time = actual_time;
  t_out = time;

  IF_MASTER_PROCESS {
    INFO("Snapshot #: %d, %e < R < %e\n, time = %e", snap, minv(R, N)*RUNIT, maxv(R, N)*RUNIT, actual_time*YEAR);
  }
}

/*
  Outputs a rate matrix, i.e. a file containing the following columns:

  R_i  R_j  rate(R_i, R_j)  i  j  outcome

  outcome is one of the outcome_t types. This file is only output if dt_rates > 0, and only by the master process (with id=0).
 */

void output_rates(double time) {
  static int output_n = 0;
  static FILE* fid_output_times = NULL;
  string fn;
  
  if (!fid_output_times) {
    sprintf(fn, "%s/rates_output_times.txt", out);
    fid_output_times = fopen(fn, "w");
    if (!fid_output_times)
      ERROR("Could not open %s for writing.\n", fn);
  }
  
  sprintf(fn, "%s/rates_%04d.txt", out, output_n);
  FILE* fid_output_rates = fopen(fn, "w");

  for (int i = 0; i < N; i++)
    for (int k = 0; k < N; k++) {
      if (R[k] > R[i])
        continue;
      double M_t_new, M_p_new;
      double dv = turbulent_coll_speed(M[i], M[k], R[i], R[k]);
      if (vd == VD_FIXED)
        dv = dv_fixed;
      
      int flag;
      outcome_t o = outcome(M[i], M[k], R[i], R[k], dv, &M_t_new, &M_p_new, &flag);

      fprintf(fid_output_rates, "%.5e %.5e %.5e %d %d %d\n",
              R[i]*RUNIT, R[k]*RUNIT, rates_ik[i][k]* events_normal_ik[i][k], i, k, (int)o);
    }

  
  
  fclose(fid_output_rates);
  fprintf(fid_output_times, "%d %e\n", output_n, time * YEAR);
  fflush(fid_output_times);
  output_n++;
}

int main(int argc, char** argv) {
#ifdef HAVE_MPI
  // Initialize MPI
  MPI_Init(NULL, NULL);
  MPI_Comm_size(MPI_COMM_WORLD, &world_size);
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  printf("Processor %d/%d started...\n", rank, world_size);
#else
  rank = 0;
  world_size = 1;
#endif

	// Initialize parameter system
	par_init(argc, argv);
	
	
  IF_MASTER_PROCESS {
    printf(BANNER_LINE);
    printf(BANNER);
    printf(BANNER_LINE);
  }
  
  // Read parameters (from command line or -in template)
#include "par_read.h"

  IF_MASTER_PROCESS {
    printf(BANNER_LINE);
    string cmd;
    sprintf(cmd, "cp used.txt %s", out);
    //system(cmd);
  }
  par_done();
  
  
  // Normalize sizes
  R_min /= AU;
  R_max /= AU;
  R_dust /= AU;
  R_fill /= AU;
  R_bounce /= AU;
  R_source_max /= AU;
  R_source_min /= AU;
  R_planetesimal /= AU;
  R_planetesimal_2 /= AU;
  R_seeds /= AU;
  
  // Normalize times
  t_max /= YEAR;
  dt_out /= YEAR;
  t_seeds /= YEAR;
  dt_rates /= YEAR;

  // Normalize freezing/melting physics parameters
  young_m /= (FORCEUNIT/(RUNIT*RUNIT));
  P_premelt /= (FORCEUNIT/(RUNIT*RUNIT));
  T_ice /= TEMPUNIT;
  T_melt /= TEMPUNIT;
  rho_premelt /= RHOUNIT;
  q_fusion /= ENERGYUNIT/MUNIT;
  k_therm /= ENERGYUNIT / (TUNIT * RUNIT * TEMPUNIT);
  c_solid /= VUNIT;
  
  
  // Mutual collision velocity
  dv_fixed /= VUNIT;
  // Solid surface density
  Sigma_0 /= SIGMAUNIT;
  // Volumetric body density
  rho /= RHOUNIT;
  // Angular velocity at a
  Omega = sqrt(MSTAR/(pow3(a)));
  // Surface density
  Sigma_g = Sigma_0 * pow(a, -Sigma_p);
  // Gas density
  rho_g = Sigma_g / (sqrt(2.*M_PI) * H * a);
  // Solid surface density
  Sigma = Sigma_g / gas_to_dust_ratio * (a > a_ice ? f_ice : 1.);
  // Sound speed
  c_g = H * a * Omega;
  // Gas pressure
  P_gas = pow(c_g,2.) * rho_g;

  
  // Gas constant, erg/deg mol
  double kB = 1.3806488e-16 / (ENERGYUNIT/TEMPUNIT);
  double mu_H2 = 2.33*1.67e-24 / MUNIT;
  
  // Gas temperature
  T_gas = pow(c_g,2.) / (kB / mu_H2);


  if (freezing && rho * RHOUNIT > 1.)
    ERROR("Freezing is on, but planetesimal density is %e g/cm^3. Initialize to a value < 1.", rho*RHOUNIT);

  // Eddy speed
  v_e = sqrt(alpha) * c_g;
  // Total solid mass in annulus
  M_tot = Sigma * M_PI * (pow2(a+da)-pow2(a));


  if (vd == VD_FULL)
    ERROR("Full velocity distribution (turbulence + drift) not implemented yet... Use vd = -1 for now (turbulence only.)\n");

  // Different seed in every process
  seed += rank;
  if (rank == 0) {
    fid_info = fopen_fmt("w", "%s/info.txt", out);
    fid_diags = fopen_fmt("w", "%s/diags.txt", out);
  };
  
  // Initialize random number generator
  rng = gsl_rng_alloc(gsl_rng_mt19937);
  gsl_rng_set(rng, seed);

  sprintf(sformat, "%ss ", format);
  sprintf(eformat, "%se ", format);
  
  // Initial distribution is dN/dR = N_0 R^{-pg}.
  // Calculate N_0 from M_tot = \int N_0 R^{-pg} M.
  double N_0 = M_tot * (4.-pg)/(4./3. * M_PI * rho * pow(R_fill, 4.-pg));
  M_dust = N_0 * 4./3. * M_PI * rho / (4.-pg) * pow(R_dust, 4.-pg);

  M_mc = M_tot - M_dust;
  tau = 2.*M_PI/(eps_pl * Omega);
  INFO("Parameters: Sigma_solids = %e, Sigma_g = %e, H_solids = %e AU, H_g = %e AU, alpha = %e, Reynolds number = %e, sound speed = %e cm/s, temperature = %e K\n",
       Sigma*SIGMAUNIT, Sigma_g*SIGMAUNIT, h*a, H*a, alpha, Re_t, c_g * VUNIT, T_gas * TEMPUNIT);
  INFO("Initial mass: %e g [%e in dust], initialized particles between %e and %e with dN/dR ~ R^-%e\n", M_tot*MSUN, M_dust/M_tot, R_dust*RUNIT, R_fill*RUNIT, pg);

  DIAGS("M_TOT", M_tot*MSUN);
  DIAGS("MUNIT", MUNIT);
  DIAGS("RUNIT", RUNIT);
  DIAGS("TUNIT", TUNIT);
  DIAGS("YEAR", YEAR);
  DIAGS("WORLD_SIZE", world_size);
  DIAGS("TAU", tau);
  DIAGS("SIGMA", Sigma);
  DIAGS("SIGMA_G", Sigma_g);
  
  INFO("Creating MC particles...\n");
  
  R = log_sample(power_law_distribution, &pg, rng,
             R_dust, R_fill, N);
  gsl_sort(R, 1, N);
  
  M = zeros(N);
  for (int i = 0; i < N; i++)
    M[i] = rho * 4./3. * M_PI * pow3(R[i]);

  interacting = izeros(N);
  ifill(interacting, N, 1);

  if (t_seeds > 0) {
    INFO("Will create seeds of size %e cm after t = %e years.\n", R_seeds*RUNIT, t_seeds*YEAR);
    R[0] = R_seeds;
    M[0] = rho * 4./3. * M_PI * pow3(R_seeds);
    interacting[0] = 0;
  }
  

  INFO("Calculating interaction rates...\n");
  // Since collision rates are symmetric [r_ik = r_ki], store as a lower
  // triangular matrix
  rates_ik = square(N);
  events_normal_ik = square(N);
  dv_ik = square(N);

  if (vd == VD_FIXED)
    for (int i = 0; i < N; i++)
      for (int j = 0; j < N; j++)
        dv_ik[i][j] = dv_fixed;

  // If resume was requested, read in the output files
  if (resume_time > 0) {
    INFO("Resuming from time %e...\n", resume_time);
    resume(resume_time);
  } else {
      fid_out = fopen_fmt("w", "%s/output.%04ld.txt", out, rank);
      fid_summ = fopen_fmt("w", "%s/summary.%04ld.txt", out, rank);
  }
  
  update_interaction_rates(0, N-1);

  save_velocity_outcome();

  if (dry_run) {
    double Ri = 1e2/RUNIT;
    double Mi = 4./3.*M_PI*rho*pow3(Ri);
    int st = 50;
    double* Rk = logspace(st, log10(1e-4/RUNIT), log10(1e2/RUNIT));
    double* dvk = logspace(st, log10(10/VUNIT), log10(500*1e2/VUNIT));
    double dummy;
    printf("%e\n", maxv(dvk, st)*VUNIT);
    FILE* fid_freeze = fopen("freeze_outcomes.txt", "w");
    for (int i = 0; i < st; i++)
      for (int k = 0; k < st; k++) {
        if (freeze(Mi, 4./3.*M_PI*rho*pow3(Rk[i]), Ri, Rk[i], dvk[k], &dummy, &dummy, &dummy, &dummy)) {
          fprintf(fid_freeze, "%e %e\n", Rk[i]*RUNIT, dvk[k]*VUNIT);
          
          }
      }
    fclose(fid_freeze);

    debug_level = 4;
    for (int i = 1; i <= 5; i++) {
      string fn;
      sprintf(fn, "freeze_v_%d.txt", i);
      FILE* fid = fopen(fn, "w");
      //debug_level = 4;
      for (int k = 0; k < st; k++) {
        double t_freeze;
        double t_contact;
        double E_binding;
        double E_collision;
        freeze(Mi, 4./3.*M_PI*rho*pow3(Rk[k]), Ri, Rk[k], pow(10., i)/VUNIT, &t_freeze, &t_contact, &E_binding, &E_collision);
        fprintf(fid, "%e %e %e %e %e\n", Rk[k]*RUNIT, t_freeze*TUNIT, t_contact*TUNIT, E_binding*ENERGYUNIT, E_collision*ENERGYUNIT);
      }
      fclose(fid);
    }
    
    ERROR("Stopping since dry run was requested.\n");
  }
  // Vectors used for rates
  rates = zeros(N);
  cum_rates = zeros(N);
  indices = izeros(N);

  double last_rates_output = -1;
  output(time, 0);
  while (time < t_max) {
    IF_MASTER_PROCESS {
      if (dt_rates > 0 && (last_rates_output < 0 || time - last_rates_output > dt_rates)) {
        output_rates(time);
        last_rates_output = time;
      }
    }
    pre_evolve_actions();
    double dt = evolve();
    time += dt;

  }
  
#ifdef HAVE_MPI
  // Cleanup MPI
  MPI_Finalize();
#endif
  return 0;
};

/* Local Variables: */
/* eval: (rainbow-delimiters-mode -1) */
/* End: */
