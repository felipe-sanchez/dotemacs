require(fields)

systemic.theme.tomorrow <- c(
    '#000000',
    '#4271ae',
    '#c82829',
    '#718c00',
    '#8959a8',
    '#3e999f',
    '#f5871f',
    '#eab700',
    '#efefef',
    '#d6d6d6'
    )
systemic.par <- list()
systemic.par$font.lab <- 2
systemic.par$tck <- 0.02

palette(systemic.theme.tomorrow)
par(systemic.par)

if (!exists('mcdm.dir')) {
mcdm.dir <- "."
mcdm.par <- NULL
mcdm.diags <- NULL
}

`%+%` <- function(s1, s2) {
    paste(s1, s2, sep="")
}

printf <- function(...) {
    cat(sprintf(...));
}

plnorm <- function(n = 1, alpha=-3.5, xmin=1e-2) {
    return((xmin^(alpha+1) * (1-runif(n)))^(1/(alpha+1)))
}


read.par <- function(f, numeric=TRUE) {
    t <- read.table(f, as.is=TRUE)
    n <- t[,1]
    if (numeric)
        t[,2] <- suppressWarnings(as.numeric(t[,2]))
    t <- as.list(t[,2])
    names(t) <- n
    return(t)
}

                                        # Loads the table
mcdm.load <- function(dir=mcdm.dir, reload=F, add=T) {
    if (reload) {
        mcdm.par <<- NULL
    }
    
    if (dir != mcdm.dir || is.null(mcdm.par) || reload) {
        mcdm.dir <<- dir
        printf("MCDM: Default dir is %s\n", mcdm.dir)
        mcdm.par <<- read.par(dir %+% "/used.txt")
        mcdm.diags <<- read.par(dir %+% "/diags.txt")
        mcdm.cols <<- read.table(dir %+% "/columns.txt", as.is=TRUE)

        if (file.exists(sprintf("%s/summary.%04d.txt", dir, 0))) {
            mcdm.summ <<- lapply(1:mcdm.diags$WORLD_SIZE, function(i) {
                return(read.table(sprintf("%s/summary.%04d.txt", dir, i-1), header=TRUE, as.is=TRUE))
            })
            rn <- sapply(mcdm.summ, function(l) nrow(l))
            if (min(rn) != max(rn)) {
                warning(sprintf("Different # of rows (%d, %d)", min(rn), max(rn)))
                mcdm.summ <<- lapply(1:length(mcdm.summ), function(i)
                                     mcdm.summ[[i]][1:min(rn), ])
            }


            mcdm.summ.avg <<- list()

            for (n in names(mcdm.summ[[1]])[-1]) {
                s <- Reduce(cbind, lapply(1:mcdm.diags$WORLD_SIZE, function(i) mcdm.summ[[i]][n]))
                mcdm.summ.avg[[n]] <<- apply(s, 1, function(r) quantile(r)['50%'])
                mcdm.summ.avg[[n %+% "_25" ]] <<- apply(s, 1, function(r) quantile(r)['25%'])
                mcdm.summ.avg[[n %+% "_75" ]] <<- apply(s, 1, function(r) quantile(r)['75%'])            
            }
            mcdm.summ.avg$TIME <<- mcdm.summ[[1]]$TIME
        }
    }
}

bands <- function(x, bottom, top, col='black', alpha=0.25, ...) {
    if (! is.na(alpha))
        col <- adjustcolor(col, alpha.f=alpha)
    polygon(c(x, rev(x)), c(top, rev(bottom)), border=NA, col=col, ...)
}


mcdm.col <- 0
mcdm.ran <- NA
mcdm.breaks <- NA

# Plot size distribution
#
# Usage:
# - Specify a time with the 't' parameter, or an output number with the 'n' parameter
# - type can be one of: 'cumulative' (a cumulative plot), 'density3' (a histogram plot; range limits are specified with the 'xlim' parameter, the number of bins with density.points), or 'points' (plot the actual particles)
# - Specify where the outputs reside with the 'dir' parameter
mcdm.plot.dist <- function(t=NA, n=NA, type='cumulative', density.points = 64, dir=mcdm.dir, reload=F, lwd=2, xlab='Radius (cm)', ylab=NA, every=5,
                           col=NA, add=F, ylim=c(0, 1), what='R', log='x', alpha=3.5, neighs=10, y.spread = 1e3, y.shift = 1, plot.points=FALSE, ...) {
    mcdm.load(dir,  reload)
    columns <- read.table(dir %+% "/columns.txt")
    times <- read.table(dir %+% "/summary.0000.txt", header=T)[,1]
    which.columns <- sprintf("%s%d", what, 1:mcdm.par$N)

    if (is.na(ylab))
        if (type == "cumulative")
            ylab <- "Cumulative distribution"
        else
            ylab <- "Density"


    stopifnot((!is.na(t)) || (!is.na(n)))
    if (is.na(n))
        n <- which(abs(times-t) == min(abs(times-t)))

    print(c(n, times[n]))

    unit <- mcdm.diags[[what %+% 'UNIT']]

    v <- Reduce(c, lapply(1:mcdm.diags$WORLD_SIZE, function(i) {
        f <- file(sprintf(mcdm.dir %+% "/output.%04d.txt", i-1), 'rb')
        seek(f, ((n-1)*length(columns))*8)
        row <- readBin(f, 'double', length(columns))
        row <- row[columns == which.columns]*unit
        close(f)
        return(row)
    }))
    print(length(v))
    v <- sort(v)
    printf("Min: %e, Max: %e\n", v[1], v[length(v)])
    printf("25: %e, 75: %e\n", quantile(v)['25%'], quantile(v)['75%'])
    
    N <- (1:length(v))/length(v)
    if (add)
        mcdm.col <<- mcdm.col + 1
    else
        mcdm.col <<- 1
    if (is.na(col)) col <- mcdm.col
    
    if (type == "cumulative") {
                                        # Cumulative distribution
        if (!add)
            plot(v, (1:length(v))/length(v), log=log, type='l', lwd=2, xlab=xlab, ylab=ylab, col=col, ...)
        else
            lines(v, (1:length(v))/length(v), lwd=2, xlab=xlab, ylab=ylab, col=col, ...)
    } else if (type == "mass") {
        m <- cumsum(v^3)/sum(v^3)
        print(length(m))
        print(length(v))
        if (!add)
            plot(v, m, log=log, type='l', lwd=2, xlab=xlab, ylab=ylab, col=col, ...)
        else
            lines(v, m, lwd=2, xlab=xlab, ylab=ylab, col=col, ...)
    } else if (type == "density") {
        warning("Do not use this...")
                                        # Density
        v2 <- 10^seq(log10(min(v)), log10(max(v)), length.out=density.points)
        N <- spline(v, N, xout=v2)$y

                                        #        plot(v, predict(sm.spline(v, N), v, 1), type='l')
        if (!add)
            plot(v2[-1], diff(N)/diff(v2), type='l', log=log, lwd=lwd, col=col, ...)
        else
            lines(v2[-1], diff(N)/diff(v2), type='l', log=log, lwd=lwd, col=col, ...)
    } else if (type == "density2") {
                                        # SPH-style density estimator
        v2 <- v[seq(1, length(v), length.out=density.points)]
        density <- c()
        h <- 1
        for (i in seq_along(v2)) {
            
            N <- max(1, sum(v > v2[i]-h & v < v2[i] + h))
            steps <- 0
            while (abs(N-neighs) > neighs/5) {
                h <- 1/40 * h * (39+(neighs/N))
                N <- max(1, sum(v > v2[i]-h & v < v2[i] + h))
                N <- if (is.na(N)) 0 else N

                if (!is.finite(h) || N == 0)
                    break
                steps <- steps + 1
                if (steps > 1000) {
                    printf("%e %e %e\n", v[i], N, h)
                    return()
                }
                    
            }
            
            dv = v[v > v2[i]-h & v < v2[i]+h] - v2[i]


            density[i] = sum(exp(-dv^2/h^2)) / (sqrt(pi) * h)
            if (i == length(v2))
                printf("%e %e %e\n", N, h, density[i])
        }
        
        if (!add) 
            plot(v2, density, type='l', col=col, lwd=lwd, log=log, xlab=xlab, ylim=ylim, ylab=ylab, ...)
        else
            lines(v2, density, type='l', col=col, lwd=lwd, log=log, ...)
    } else if (type=='points') {
        if (is.na(mcdm.ran) || length(mcdm.ran) != length(v)) {
            mcdm.ran <<- runif(length(v), 0, y.spread)
        }
        print(col)
        if (!add)
            plot(v, mcdm.ran+t, log=log, col=col, xlab=xlab, ylab=ylab, ylim=ylim, ...)
        else
            points(v, mcdm.ran+t, log=log, col=col, ...)
    } else if (type=="density3") {
        pars <- list(...)

        if (min(v) < min(pars$xlim)) {
            warning(sprintf("min(v) = %e, min(xlim) = %e, truncating v",
                            min(v), min(pars$xlim)))
            v <- v[v>min(pars$xlim)]
        }
        if (max(v) > max(pars$xlim)) {
            warning(sprintf("max(v) = %e, max(xlim) = %e, truncating v",
                            max(v), max(pars$xlim)))
            v <- v[v<max(pars$xlim)]
        }
        breaks <- seq(log10(min(pars$xlim)), log10(max(pars$xlim)), length.out=density.points)

        bcol <- col
        col <- adjustcolor(col, alpha.f=0.1)
        h <- hist(log10(v), breaks=breaks, plot=F)
        h$counts <- log10(h$counts)

        plot(h, add=add,
                   border=col, col=col, lty=0, xlab=xlab, ylab=ylab,
                  ylim=log10(ylim), xlim=log10(pars$xlim), log=log, main=pars$main)
        lines(h$mids - 0.5*(h$mids[2]-h$mids[1]), h$counts, type='s', col=bcol, lwd=lwd)
        lines(h$mids + 0.5*(h$mids[2]-h$mids[1]), h$counts, type='S', col=bcol, lwd=lwd)
        if (plot.points)
            points(h$mids, h$counts, col=bcol, pch=19, cex=0.5)
        
        return(invisible(h))
        
    }
    return(invisible(v))
    
}

mcdm.plot.q <- function(q=c(0.01, 0.05, 0.25, 0.5, 0.75, 0.95, 0.99), dir = mcdm.dir, reload=FALSE, lwd=2, xlab='Time [years]', ylab='Size [cm]', log='y', ylim=NULL, what='R', skip=1, col=1:length(q), legend.pos='bottomright',
                        shaded=FALSE, ...) {
    unit <- mcdm.diags[[what %+% 'UNIT']]

    files <- lapply(1:mcdm.diags$WORLD_SIZE, function(i) file(sprintf(dir %+% "/output.%04d.txt", i-1), 'rb'))
    on.exit(lapply(files, close))

    columns <- read.table(dir %+% "/columns.txt")
    times <- read.table(dir %+% "/summary.0000.txt", header=TRUE)[,1]
    which.columns <- sprintf("%s%d", what, 1:mcdm.par$N)

    doplot <- function(times, qm) {
        if (is.null(ylim))
            ylima <- c(min(qm), max(qm))
        else
            ylima <- ylim
        
        times2 <- times[seq(1, by=skip, length.out=ncol(qm))]

        if (!shaded) {
            plot(times2, qm[1,], log=log, ylim=ylima, type='l', xlab=xlab, ylab=ylab, lwd=lwd, col=col[1], ...)
            for (i in 2:nrow(qm))
                lines(times2, qm[i,], lwd=lwd, col=col[i], ...)

            legend(legend.pos, legend=paste(q*100, "%", sep=""), lwd=lwd, col=col)
        } else {
            med <- round(length(q)/2)
            plot(times2, qm[med,], log=log, ylim=ylima, type='l', xlab=xlab, ylab=ylab, lwd=lwd, col=col[1], ...)

            label <- 'Median'
            lwds <- lwd
            cols <- col[1]
            
            for (i in 1:(med-1)) {
                bands(times2, qm[i,], qm[nrow(qm)-i+1,], alpha=0.2)
                label <- c(label, paste(q[i]*100, "%-", q[length(q)-i+1]*100, "%", sep=''))
                cols <- c(cols, rgb(0, 0, 0, 0.2*i))
                lwds <- c(lwds, 10)
            }
            lines(times2, qm[med,], log=log, ylim=ylima, type='l', xlab=xlab, ylab=ylab, lwd=lwd, col=col[1], ...)
            legend(legend.pos, legend=label, lwd=lwds, col=cols)

            
        }
    }
    
    qm <- NULL
    eof <- FALSE
    l <- 1
    while (TRUE) {
        qs <- NULL
        for (i in 1:mcdm.diags$WORLD_SIZE) {
            for (j in 1:skip) 
                row <- readBin(files[[i]], 'double', length(columns))
            
            if (is.null(row) || length(row) == 0) {
                eof <- TRUE
                break
            }

            b <- row[columns == which.columns]*unit
            qs <- cbind(qs, quantile(b, q))
            
            
            if (l == 1)
                print(summary(b))
        }
        if (eof)
            break

        qm <- cbind(qm, rowMeans(qs))
        l <- l + 1
        doplot(times, qm)
    }

    doplot(times, qm)

    
    return(invisible(list(times, qm)))
    
}


                                        # Plot mass fractions as a function of time
mcdm.plot.frac <- function(add=FALSE, dir=mcdm.dir,  reload=F, lwd=2, bands=TRUE, xlab='Time [years]', ylab='Mass fraction', ylim=c(0, 1), col=NA,
                           ...) {
    mcdm.load(dir,  reload)    
    
    t <- mcdm.summ.avg$TIME
    if (!add)
        plot(t, mcdm.summ.avg$M_DUST, type='n', xlab=xlab, ylab=ylab, ylim=ylim,  ...)
    if (is.na(col))
        col <- 2:10

    with(mcdm.summ.avg, {
        bands(t, M_DUST, M_DUST_25, M_DUST_75, col=col[1])
        bands(t, M_SOURCE_MIN, M_SOURCE_MIN_25, M_SOURCE_MIN_75, col=col[2])
        bands(t, M_SOURCE_MAX, M_SOURCE_MAX_25, M_SOURCE_MAX_75, col=col[3])
        bands(t, M_PLANETESIMAL, M_PLANETESIMAL_25, M_PLANETESIMAL_75, col=col[4])
        bands(t, M_PLANETESIMAL2, M_PLANETESIMAL2_25, M_PLANETESIMAL2_75, col=col[5])
        lines(t, M_DUST, lwd=lwd, col=col[1])
        lines(t, M_SOURCE_MIN, lwd=lwd, col=col[2]);
        lines(t, M_SOURCE_MAX, lwd=lwd, col=col[3]);
        lines(t, M_PLANETESIMAL, lwd=lwd, col=col[4]);
        lines(t, M_PLANETESIMAL2, lwd=lwd, col=col[5]);    
    })

    if (!add) {
        legendn <-  
            c(sprintf("R < %.0f cm", mcdm.par$R_dust),
              sprintf("%.0f cm < R < %.0f cm", mcdm.par$R_dust, mcdm.par$R_source_min),
              sprintf("%.0f cm < R < %.0f cm", mcdm.par$R_source_min, mcdm.par$R_source_max),
              sprintf("%.0f cm < R < %.0f km", mcdm.par$R_source_max, mcdm.par$R_planetesimal/1e5),
              sprintf("%.0f km < R < %.0f km", mcdm.par$R_planetesimal/1e5, mcdm.par$R_planetesimal_2/1e5),
              sprintf("R > %.0f km", mcdm.par$R_planetesimal_2/1e5))
        

        legend('topleft', legendn, lwd=2, col=col)
    }
    

    
}

mcdm.plot.particles <- function(dir='.', reload=F, what='R', ...) {
    
    mcdm.load(dir,  reload)    
    columns <- read.table(dir %+% "/columns.txt")
    a <- read.table(dir %+% '/summary.0000.txt', header=TRUE, as.is=TRUE)
    
    b <- readBin(dir %+% '/output.0000.txt', 'double', n=length(columns)*nrow(a))
    b <- matrix(b, nrow=nrow(a))
    which.columns <- sprintf("%s%d", what, 1:mcdm.par$N)
    b <- b[, columns == which.columns, drop=FALSE]


    return(b)
}

mcdm.labels <- c('Stick', 'Bounce',
                 'MT/Erosion', 'Fragm.',
                 'GravMerge', 'Freeze')

plot.outcomes <- function(dir='.', reload=F, ...) {
    mcdm.load(dir,  reload)
    a <- read.table(dir %+% "/outcomes.txt")
    a[,4] <- a[,4]+1

    x <- seq(log10(min(a[,1])), log10(max(a[,1])),
             length.out=sqrt(length(a[,1])))
    print(seq_along(mcdm.labels))
    image.plot(x, x, matrix(a[,4], length(x), length(x)),
               axis.args=list(at=seq_along(mcdm.labels)-0.5, labels=mcdm.labels),
               col=tim.colors(6), horizontal=T,  
               zlim=c(0, length(mcdm.labels)), ...)
    title(bquote(alpha == 10^.(log10(mcdm.par$alpha))))
}

mcdm.rates.boundary = NULL

plot.rates <- function(t=NA, dir='.', reload=F, xlim=NULL, zlim=NULL, pal=rainbow, ...) {
    if (is.na(t))
        stop("Specify a time")
    if (is.null(zlim))
        stop("Specify zlim")
    mcdm.load(dir,  reload)
    a <- read.table(dir %+% "/outcomes.txt")
    a[,4] <- a[,4]+1

    x <- seq(log10(min(a[,1])), log10(max(a[,1])),
             length.out=sqrt(length(a[,1])))
    if (is.null(mcdm.rates.boundary) || reload) {
        m <- matrix(a[,4], length(x), length(x))
        m[m==3] <- 10
        m[m==4] <- 20
        m[m==5] <- 30
    
        i <- 1:nrow(m)
        k <- lapply(i, function(i) abs(diff(m[i, ])) > 1)


        xx <- c()
        yy <- c()
        for (ii in i) {
            kk <- k[[ii]]
            R <- x[kk]
            xx <- c(xx, rep(x[ii], times=length(R)), R)
            yy <- c(yy, R, rep(x[ii], times=length(R)))
        }
        mcdm.rates.boundary = list(xx, yy)
    }
    if (is.null(xlim))
        xlim <- range(mcdm.rates.boundary[[1]])
    
    plot(mcdm.rates.boundary[[1]], mcdm.rates.boundary[[2]], xlim=xlim, ylim=xlim, type='p', col='gray', pch=19, cex=1, ...)

    a <- read.table(dir %+% "/rates_output_times.txt")
    n <- which.min(abs(a[,2] - t))-1
    print(n)
    print(a[n,2])

    m <- read.table(dir %+% sprintf("/rates_%04d.txt", n))

    
    m[,1] <- log10(m[,1])
    m[,2] <- log10(m[,2])
    
    zlim <- log10(zlim)
    nlevels <- 40
    r <- pal(nlevels)
    i <- m[,3]==0
    print(range(m[m[,3]>0,3]))
    
    m[,3] <- log10(m[,3])
    m[m[,3]>max(zlim),3] <- max(zlim)
    m[m[,3]<min(zlim),3] <- min(zlim)
    c <- ceiling((m[,3]-min(zlim))/(max(zlim)-min(zlim)) * (nlevels-1)) + 1
    print(range(c))
    c <- r[c]
    c[i] <- "black"
    
    
    points(m[,1], m[,2], col=c, pch=19, cex=0.5, ...)
    points(m[,2], m[,1], col=c, pch=19, cex=0.5, ...)

    
    

}


plot.arrows <- function(dir='.', reload=F, n = 20, ...) {
    error("Not working.")
    mcdm.load(dir,  reload)
    a <- read.table(dir %+% "/outcomes.txt")
    R.targ <- (a[,7]*mcdm.diags$MUNIT/(4./3.*pi*mcdm.par$rho))^(1./3.)
    
    idx <- seq(1, nrow(a), length.out=n)
    
    plot(x=1, y=1, type='n', xlim=range(a[,1]), ylim=range(a[,1]), ...)

    for (i in idx)
        for (j in seq(i, i+sqrt(nrow(a)), length.out=n)) {
            if (a[i,1] >= a[j,2]) {
                
                arrows(a[i,1], a[j,2], R.targ[j], a[j,2],length=0)
            }
        }
    return(invisible(R.targ))
}


plot.speeds <- function(dir='.', reload=F, speed.range=NULL, ...) {
    mcdm.load(dir,  reload)
    a <- read.table(dir %+% "/outcomes.txt")

    x <- seq(log10(min(a[,1])), log10(max(a[,1])),
             length.out=sqrt(length(a[,1])))

    if (speed.range)
        a[a[,3] < speed.range[1] | a[,3] > speed.range[2],3] <- NA
    image.plot(x, x, log10(matrix(a[,3], length(x), length(x))),
               ...)
    title(bquote(alpha == 10^.(log10(mcdm.par$alpha))))
}

plot.accr <- function(dir='.', reload=F, ...) {
    mcdm.load(dir,  reload)
    a <- read.table(dir %+% "/outcomes.txt")

    b <- a[,5]
    b[a[,5] == 0] <- 0
    b[a[,5] < 0] <- -1
    b[a[,5] > 0] <- 1

    ratio <- mcdm.par$M_threshold^(1/3)
    b[a[,1] < ratio*a[,2]] <- 1
    b[a[,2] < ratio*a[,1]] <- 1
    
    
    x <- seq(log10(min(a[,1])), log10(max(a[,1])),
             length.out=sqrt(length(a[,1])))
    
    image.plot(x, x, matrix(b, length(x), length(x)),
               axis.args=list(at=c(-1, 0, 1), labels=c('Eroding impact', 'No change', 'Accreting impact')), horizontal=T,
               ...)
    title(bquote(alpha == 10^.(log10(mcdm.par$alpha))))
}

plot.freezing <- function(dir='.', what='times', ...) {
    l <- c()


    if (what == 'energies') {
        x <- 4
        y <- 5
        plot(c(1e-4, 1e2), c(1e-10, 1e7), type='n', ...)

        cat('Dashed: binding, solid: collision\n')
    } else if (what == 'times') {
        x <- 2
        y <- 3

        plot(c(1e-4, 1e2), c(1e-10, 10), type='n', ...)
        cat('Dashed: freeze time, solid: contact time\n')
    }
        
    for (i in 1:5) {
        fn <- sprintf("%s/freeze_v_%d.txt", dir, i)
        a <- read.table(fn)
        lines(a[,1], a[,x], lty=2, col=i, ...)
        lines(a[,1], a[,y], col=i, ...)
        l <- c(l, sprintf('v = 10^%d cm/s', i))
    }

    
    legend('topleft', l, col=1:5, lwd=2)
    
}

convert.to.text <- function(dir='.', reload=F, out='~/Desktop/out.txt', times=NA, what='R', ...) {
    mcdm.load(dir,  reload)
    columns <- read.table(dir %+% "/columns.txt")
    time.column <- read.table(dir %+% "/summary.0000.txt", header=T)[,1]
    which.columns <- sprintf("%s%d", what, 1:mcdm.par$N)

    if (is.na(times))
        times = seq(min(time.column), max(time.column), length.out=25)
    
    print(times)
    unit <- mcdm.diags[[what %+% 'UNIT']]

    fout <- file(out, open='w')
    cat(file=fout, sprintf('# N = %d, WORLD_SIZE = %d\n', mcdm.par$N, mcdm.diags$WORLD_SIZE))
    
    for (time in times) {
        
        n <- which(abs(time.column-time) == min(abs(time.column-time)))
        
        printf("%d %e\n", n, time)
        
        v <- Reduce(c, lapply(1:mcdm.diags$WORLD_SIZE, function(i) {
            f <- file(sprintf(mcdm.dir %+% "/output.%04d.txt", i-1), 'rb')
            seek(f, ((n-1)*length(columns))*8)
            row <- readBin(f, 'double', length(columns))
            row <- sort(row[columns == which.columns]*unit)
            close(f)
            return(row)
        }))

        cat(file=fout, sprintf("%18.6e ", time))
        cat(file=fout, sprintf("%18.6e ", v))
        cat(file=fout, "\n")
    }

    
    close(fout)
}
