require 'utils'
require 'systemic'

local dir = os.getenv("HOME") .. "/Projects/SystemicLive"

function preprocess(fn)
	local f = io.open(fn)
	local str = f:read("*a")
	str = str:gsub("%#include .-\n", ""):gsub("//.-\n", ""):gsub("%/%*.-%*%/", "")	
	return str
end

-- Read important systemic includes
local b = buf.buffer():append( "#define PARSE\n", preprocess("../src/systemic.h"), preprocess("../src/javascript.h"), preprocess("../src/utils.h"), preprocess("../src/periodogram.h"), preprocess("../src/kernel.h"))
b:save(".tmp.h")

local b2 = buf.buffer():append(ex.capture("/usr/local/bin/cpp -P -E -w .tmp.h"))
b2:save(".tmp.h")

local out = buf:buffer()
out:append("\t// Constants\n")
for const, val in b:tostring():gmatch("%#define ([%w_]+) ([%de%+%-%.]+)") do
	out:appendf("\tvar %s = %s;\n", const, val)
end

for lab, num in b:tostring():gmatch("%#define ([%w_]+) %(1 << (%d+)%)") do
	out:appendf("\tvar %s = %d;\n", lab, 2^tonumber(num))
end

local types = {
	void = "void",
	char = "char",
	short = "number",
	int = "int",
	long = "long",
	longint = "number",
	longlong = "number",
	float = "number",
	constchar = "string",
	bool = "number",
	double = "number",
	ok_callback = "number",
	ok_callback2 = "number",
	ok_progress	= "number",
	ok_model_function = "number",
	ok_kernel = "number",
	size_t = "number",
	doublereal = "number"
}

out:append("\t// Function bindings\n")
local exp = buf.buffer()
exp:append("EXP_FUNCTIONS=-s EXPORTED_FUNCTIONS=\"[")

--local syms = io.open("symbols.txt", "w")
for ret, name, list in b2:tostring():gsub(";", ";\n"):gmatch("%s*([%w%s%_%*]+) ([^()*;]-)%(([^()]-)%);\n") do
	list = list:gsub("\n", " ")
	
	local args = ex.split(list, ",")
	local sig = buf.buffer()
	table.insert(args, 1, ret .. " ")
	
	--syms:write(name .. "\n")
	sig:appendf("var %s = Module.cwrap('%s', ", name, name)
	exp:append("'_", name, "', ")
	
	for i = 1, #args do
		local type, name = args[i]:match("^(.+)%s+(.-)$")
		type = ex.trim(type:gsub(" ", ""))
		
		if i == 2 then
			sig:append("[")
		end
		local sign
		
		if type == "constchar*" then
			sign = ("string")
		elseif type == "void*" then
			sign = ("number")
		elseif type:find("%*%*") then
			sign = ("number")
		else
			ispointer = type:find("%*") or name:find("%[")
			type = ex.trim(type:gsub("%*", ""))
			isunsigned = type:find("unsigned")
			type = ex.trim(type:gsub("unsigned", ""):gsub("const", ""))
			
			local sigt = types[type]
			if not sigt or (ispointer and i == #args) then
				if ispointer then
					sigt = string.format("number", type)
				else
					error(table.concat({type, name, ret, list}, " "))
				end
			else
				sigt = "number"
			end
			
			sign = sigt
		end
		
		if i == #args then
			if i ~= 1 then sign = sign .. "']" else sign = sign .. "'" end
			sig:append("'", sign, ")")
		else
			sig:append("'", sign, "', ")
		end
	end
	out:append("\t", sig:tostring(), ";\t", string.format("// %s %s(%s)", ret, name, list), "\n")
end
exp:append("'_main']\"\n")
local i = io.open(dir .. "/js/systemic.js"):read("*a")
i = i:gsub("// BEGIN_AUTO(.*)// END_AUTO", "// BEGIN_AUTO\n" .. out:tostring() .. "\n\t// END_AUTO")
local fid = io.open(dir .. '/js/systemic.js', 'w')
fid:write(i)
fid:close()

exp:save(dir .. "Makefile_include")

-- out:save("../packaging/forweb/javasdefs.r")
